# make sure you're logged in with `huggingface-cli login`
import os
import shutil
import time
import uuid
from dataclasses import dataclass, field
from io import BytesIO

import PIL
import requests
import torch
from diffusers import (
    DiffusionPipeline,
    DPMSolverMultistepScheduler,
    StableDiffusionDepth2ImgPipeline,
    StableDiffusionPipeline,
    StableDiffusionUpscalePipeline,
)


class StableDiffusionConfig:
    """
    A class that wraps the Stable Diffusion models from Hugging Face with configuration options.
    """

    def __init__(
        self,
        pipeline: DiffusionPipeline = StableDiffusionPipeline,
        repo_name: str = "runwayml/stable-diffusion-v1-5",
        title: str = None,
        scheduler: bool = False,
        pipeline_options: dict = None,
    ) -> None:
        """
           Initialize the Stable Diffusion class with the pipeline, repo_name, and title values.
        Args:
            pipeline: one of StableDiffusionPipeline or DiffusionPipeline
            repo_name: The name of the repo to load the model from
            title: The type of stable diffusion model to load
            scheduler: Whether to use the scheduler or not
        """
        self.title = title
        self.pipe = (
            pipeline.from_pretrained(repo_name, **pipeline_options)
            if pipeline_options
            else pipeline.from_pretrained(repo_name)
        )
        self.pipe = self.pipe.to("mps")
        self.pipe.enable_attention_slicing()
        if scheduler:
            self.pipe.scheduler = DPMSolverMultistepScheduler.from_config(
                pipe.scheduler.config
            )

    def txt2img(self, prompt: str, **options: dict):
        """
        Convert text to an image using the Stable Diffusion model.
        Args:
            prompt: The text to convert to an image
            **options:
                num_inference_steps: The number of inference steps to take
                guidance_scale: The scale of the guidance
        Returns:
            The image generated by the model.
        """
        return self.pipe(prompt, **options).images[0]


@dataclass
class StableDiffusionV1:
    repo_name = "runwayml/stable-diffusion-v1-5"
    pipeline = StableDiffusionPipeline


@dataclass
class StableDiffusionV2Base:
    repo_name = "stabilityai/stable-diffusion-2-base"
    scheduler = True
    num_inference_steps = 25
    pipeline = StableDiffusionPipeline


@dataclass
class StableDiffusionV2:
    repo_name = "stabilityai/stable-diffusion-2"
    scheduler = True
    num_inference_steps = 25
    guidance_scale = 9
    pipeline = DiffusionPipeline


@dataclass
class StableDiffusion4xUpscale:
    repo_name = "stabilityai/stable-diffusion-x4-upscaler"
    pipeline = StableDiffusionUpscalePipeline
    torch_dtype = torch.float16


@dataclass
class StableDiffusionDepth2Img:
    repo_name = "stabilityai/stable-diffusion-2-depth"
    pipeline = StableDiffusionDepth2ImgPipeline
    strength = 0.7


def generate_all_models(**options):
    """
    Generate images with the Stable Diffusion models.
    Returns:
        None
    """
    # times = []
    for cls in MODELS:
        try:
            start_time = time.time()
            total_time = make_image(cls)
            # times.append({"model": cls.__name__, "time": total_time})
            end_time = time.time()
            total_time = end_time - start_time
            # times.append({"model": cls.__name__, "time": total_time})
        except Exception as e:
            if options.get("verbose", True):
                print(e)
            if options.get("speech", True):
                os.system(f"say '{cls.__name__} failed'")
    if options.get("speech", True):
        os.system("say 'jobs done'")
    # sort times by fastest to slowest
    # times = sorted(times, key=lambda x: x["time"])
    # if options.get("verbose", True):
    #     print(times)


def make_image(
    cls,
    image_class,
    regenerate_prompt=None,
    verbosity=True,
    speech=True,
):
    """
    Generate an image with the Stable Diffusion model and save it to the output folder.
    Args:
        cls: The Stable Diffusion model class
        image_class: The image object with stateful information regarding file paths and prompts
        verbosity: Whether to print steps to the console
        speech: Whether to use the speech synthesizer to say the model name
        regenerate_prompt: Whether to regenerate the image if it already exists and use a different prompt
    """
    # check if the image has already been generated
    if not regenerate_prompt:
        for image in image_class.saved_images:
            if cls.title in image:
                if verbosity:
                    print(f"Image with {cls.title} already exists")
                return
        if verbosity:
            print(f"Generating image with {cls.title}")
    prompt = regenerate_prompt or image_class.prompt_line
    img = cls.txt2img(prompt=prompt)
    save_path = image_class.save_image(cls, img)
    if speech:
        os.system(f"say '{cls.title} done'")
    print(f"Generated image with {cls.title} at {save_path}")


@dataclass
class Project:
    """
    A class to hold the project information.
    """

    id: str
    prompt: str = ""
    master_folder: str = "outputs"
    output_folder: str = None
    image_indices: list = field(default_factory=list)
    models: list = field(default_factory=list)

    def __post_init__(self):
        """
        Create the output folder and save the prompt
        """
        self.output_folder = f"{self.master_folder}/{self.id}"
        if not os.path.exists(self.master_folder):
            os.mkdir(self.master_folder)
        if not os.path.exists(self.output_folder):
            os.mkdir(self.output_folder)
        if not os.path.exists(f"{self.output_folder}/prompt.txt"):
            with open(f"{self.output_folder}/prompt.txt", "w") as f:
                f.write(self.prompt)

    def load(self):
        """
        Load a project from the master folder
        """
        self.output_folder = f"{self.master_folder}/{self.id}"
        with open(f"{self.output_folder}/prompt.txt", "r") as f:
            self.prompt = f.read()
        self.models = []
        # scan the image index folders to find each folder name that was created
        for folder in os.listdir(self.output_folder):
            if folder == "prompt.txt":
                continue
            for subfolder in os.listdir(f"{self.output_folder}/{folder}"):
                if subfolder not in self.models and not subfolder.endswith(".txt"):
                    self.models.append(subfolder)
        self.models = set(self.models)
        self.setup_prompt_indices()

    def setup_prompt_indices(self):
        for index, line in enumerate(self.prompt.splitlines()):
            if line:
                print(f"index: {index}, line: {line}")
                image_index = ImageIndex(index=index, project=self, prompt_line=line)
                image_index.add_indexes_folder()
                image_index.add_prompts_file()
                image_index.add_class_folders(self.models)
                for model in self.models:
                    if os.path.exists(
                        f"{image_index.index_folder}/{model}/{index}.png"
                    ):
                        image_index.saved_images.append(
                            f"{image_index.index_folder}/{model}/{index}.png"
                        )
                self.image_indices.append(image_index)

    def models_to_images(self):
        """
        Generate images for each model in the project
        """
        for model in self.models:
            sd_config = self.config_class(model)
            for image_index in self.image_indices:
                print(f"Generating image for line {image_index.index} with {model}")
                make_image(
                    sd_config,
                    image_index,
                )

    @staticmethod
    def config_class(cls):
        if isinstance(cls, str):
            cls = globals()[cls]
        sd = cls()
        return StableDiffusionConfig(title=cls.__name__, **sd.__dict__)


@dataclass
class ImageIndex:
    index: int
    project: Project
    prompt_line: str
    index_folder: str = None
    prompt_file: str = None
    class_folders: list = field(default_factory=list)
    saved_images: list = field(default_factory=list)

    def add_indexes_folder(self):
        """
        Add a folder for the index
        """
        index_folder = f"{self.project.output_folder}/{self.index}"
        if not os.path.exists(index_folder):
            os.mkdir(index_folder)
        if os.path.exists(index_folder):
            self.index_folder = index_folder
        else:
            raise ValueError("index_folder failed to be created")

    def add_prompts_file(self):
        """
        Add a file for the prompt
        """
        if self.index_folder is None:
            raise ValueError("index_folder must be set")
        prompt_file = f"{self.index_folder}/{self.index}_prompt.txt"
        with open(prompt_file, "w") as f:
            f.write(self.prompt_line)
        if not os.path.exists(prompt_file):
            raise ValueError("prompt_file failed to be created")
        self.prompt_file = prompt_file

    def add_class_folders(self, classes: list[str]):
        """
        Add a folder for the class
        classes: a list of classes to add folders for
        """
        if self.index_folder is None:
            raise ValueError("index_folder must be set")
        for cls in classes:
            if isinstance(cls, str):
                class_folder = f"{self.index_folder}/{cls}"
            else:
                class_folder = f"{self.index_folder}/{cls.__name__}"
            if not os.path.exists(class_folder):
                os.mkdir(class_folder)
            if os.path.exists(class_folder):
                self.class_folders.append(class_folder)
            else:
                raise ValueError("class_folder failed to be created")

    def save_image(self, sd_model: str, img: PIL.Image):
        """
        Create a filename and path for the image
        """
        save_path = f"{self.index_folder}/{sd_model.title}/{self.index}.png"
        img.save(save_path)
        if not os.path.exists(save_path):
            raise ValueError("save_path failed to be created")
        self.saved_images.append(save_path)
        return save_path


MODELS = [
    StableDiffusionV1,
    StableDiffusionV2,
    StableDiffusionV2Base,
    StableDiffusion4xUpscale,
    StableDiffusionDepth2Img,
]


def batch_generate_images(prompt_path: str = "input/prison_full.txt"):
    """
    Generate A batch of images for each line of the prompt
    """
    with open(prompt_path, "r") as f:
        prompt = f.read()

    new_project = Project(id=str(uuid.uuid4()), prompt=prompt, models=MODELS)
    new_project.setup_prompt_indices()
    new_project.models_to_images()


def resume_batch_images(id: str):
    """
    Resume a batch of images for each line of the prompt
    """
    project = Project(id=id)
    project.load()
    project.models_to_images()


def from_single_prompt(prompt: str = None):
    """
    Generate A batch of images for each line break of the prompt
    """
    if not prompt:
        prompt = input("Enter prompt: ")
    new_project = Project(id=str(uuid.uuid4()), prompt=prompt, models=MODELS)
    new_project.setup_prompt_indices()
    new_project.models_to_images()


def delete_filtered_images(project_id: str):
    """
    Scan a projects image files for any images that have been filtered by nsfw filter and delete them
    Filtered images are all black
    """
    breakpoint()
    project = Project(id=project_id)
    project.load()
    for image_index in project.image_indices:
        for saved_image in image_index.saved_images:
            img = PIL.Image.open(saved_image)
            if img.getbbox() is None:
                print(f"Deleting {saved_image}")
                os.remove(saved_image)
            else:
                print(f"Keeping {saved_image}")


PROJECT_ID = "33527d88-636b-4833-876d-6d0665d970b5"


def regenerate_image(
    project_id: str,
    index: int,
    model: str,
    prompt_prefix: str = None,
    prompt_suffix: str = None,
):
    """
    Regenerate a single image
    """
    project = Project(id=project_id)
    project.load()
    image_index = project.image_indices[index]
    sd_config = project.config_class(model)
    current_prompt = image_index.prompt_line
    if prompt_prefix:
        current_prompt = f"{prompt_prefix} {current_prompt}"
    if prompt_suffix:
        current_prompt = f"{current_prompt} {prompt_suffix}"
    # make copies of the current images
    backup_folder = f"{image_index.index_folder}/backup"
    backup_index = 0
    backed_up = False
    while not backed_up:
        backup_folder = f"{backup_folder}_{backup_index}"
        if not os.path.exists(backup_folder):
            os.mkdir(backup_folder)
            backed_up = True
        else:
            backup_index += 1
    for saved_image in image_index.saved_images:
        # find the model name in the saved image path
        model_name = saved_image.split("/")[-2]
        os.mkdir(f"{backup_folder}/{model_name}")
        shutil.copy(saved_image, f"{backup_folder}/{model_name}")
    # make new prompt txt file in the folder of the model being regenerated
    prompt_file = f"{image_index.index_folder}/{sd_config.title}/{image_index.index}_prompt_regen.txt"
    with open(prompt_file, "w") as f:
        f.write(current_prompt)
    make_image(sd_config, image_index, regenerate_prompt=current_prompt)


if __name__ == "__main__":
    regenerate_image(
        PROJECT_ID,
        0,
        "StableDiffusionV1",
        prompt_prefix="lo res",
        prompt_suffix="hanna barbara",
    )

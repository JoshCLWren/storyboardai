# make sure you're logged in with `huggingface-cli login`
import os
import time
import uuid
from dataclasses import dataclass, field
from io import BytesIO

import PIL
import requests
import torch
from diffusers import (
    DiffusionPipeline,
    DPMSolverMultistepScheduler,
    StableDiffusionDepth2ImgPipeline,
    StableDiffusionPipeline,
    StableDiffusionUpscalePipeline,
)


class StableDiffusionConfig:
    """
    A class that wraps the Stable Diffusion models from Hugging Face with configuration options.
    """

    def __init__(
        self,
        pipeline: DiffusionPipeline = StableDiffusionPipeline,
        repo_name: str = "runwayml/stable-diffusion-v1-5",
        title: str = None,
        scheduler: bool = False,
        pipeline_options: dict = None,
    ) -> None:
        """
           Initialize the Stable Diffusion class with the pipeline, repo_name, and title values.
        Args:
            pipeline: one of StableDiffusionPipeline or DiffusionPipeline
            repo_name: The name of the repo to load the model from
            title: The type of stable diffusion model to load
            scheduler: Whether to use the scheduler or not
        """
        self.title = title
        self.pipe = (
            pipeline.from_pretrained(repo_name, **pipeline_options)
            if pipeline_options
            else pipeline.from_pretrained(repo_name)
        )
        self.pipe = self.pipe.to("mps")
        self.pipe.enable_attention_slicing()
        if scheduler:
            self.pipe.scheduler = DPMSolverMultistepScheduler.from_config(
                pipe.scheduler.config
            )

    def txt2img(self, prompt: str, **options: dict):
        """
        Convert text to an image using the Stable Diffusion model.
        Args:
            prompt: The text to convert to an image
            **options:
                num_inference_steps: The number of inference steps to take
                guidance_scale: The scale of the guidance
        Returns:
            The image generated by the model.
        """
        return self.pipe(prompt, **options).images[0]


@dataclass
class StableDiffusionV1:
    repo_name = "runwayml/stable-diffusion-v1-5"
    pipeline = StableDiffusionPipeline


@dataclass
class StableDiffusionV2Base:
    repo_name = "stabilityai/stable-diffusion-2-base"
    scheduler = True
    num_inference_steps = 25
    pipeline = StableDiffusionPipeline


@dataclass
class StableDiffusionV2:
    repo_name = "stabilityai/stable-diffusion-2"
    scheduler = True
    num_inference_steps = 25
    guidance_scale = 9
    pipeline = DiffusionPipeline


@dataclass
class StableDiffusion4xUpscale:
    repo_name = "stabilityai/stable-diffusion-x4-upscaler"
    pipeline = StableDiffusionUpscalePipeline
    torch_dtype = torch.float16


@dataclass
class StableDiffusionDepth2Img:
    repo_name = "stabilityai/stable-diffusion-2-depth"
    pipeline = StableDiffusionDepth2ImgPipeline
    strength = 0.7


MODELS = [
    StableDiffusionV1,
    StableDiffusionV2,
    StableDiffusionV2Base,
    StableDiffusion4xUpscale,
    StableDiffusionDepth2Img,
]


def generate_all_models(**options):
    """
    Generate images with the Stable Diffusion models.
    Returns:
        None
    """
    # times = []
    for cls in MODELS:
        try:
            start_time = time.time()
            total_time = make_image(cls)
            # times.append({"model": cls.__name__, "time": total_time})
            end_time = time.time()
            total_time = end_time - start_time
            # times.append({"model": cls.__name__, "time": total_time})
        except Exception as e:
            if options.get("verbose", True):
                print(e)
            if options.get("speech", True):
                os.system(f"say '{cls.__name__} failed'")
    if options.get("speech", True):
        os.system("say 'jobs done'")
    # sort times by fastest to slowest
    # times = sorted(times, key=lambda x: x["time"])
    # if options.get("verbose", True):
    #     print(times)


def make_image(
    cls,
    images_index,
    verbosity=True,
    speech=True,
):
    """
    Generate an image with the Stable Diffusion model and save it to the output folder.
    Args:
        cls: The Stable Diffusion model class
        images_index: The image index object with state information regarding file paths and propmt
        verbosity: Whether to print steps to the console
        speech: Whether to use the speech synthesizer to say the model name
    """

    if verbosity:
        print(f"Generating image with {cls.title}")

    img = sd_config.txt2img(prompt=images_index.prompt_line)
    save_path = images_index.save_image(cls, img)
    if speech:
        os.system(f"say '{cls.title} done'")
    print(f"Generated image with {cls.title} at {save_path}")


def config_class(cls):
    sd = cls()
    return StableDiffusionConfig(title=cls.__name__, **sd.__dict__)


@dataclass
class Project:
    """
    A class to hold the project information.
    """

    id: str
    prompt: str
    master_folder: str = "outputs"
    output_folder: str = None

    def __post_init__(self):
        """
        Create the output folder and save the prompt
        """
        self.output_folder = f"{self.master_folder}/{self.id}"
        if not os.path.exists(self.master_folder):
            os.mkdir(self.master_folder)
        if not os.path.exists(self.output_folder):
            os.mkdir(self.output_folder)
        with open(f"{self.output_folder}/prompt.txt", "w") as f:
            f.write(self.prompt)


@dataclass
class ImageIndex:
    index: int
    project: Project
    prompt_line: str
    index_folder: str = None
    prompt_file: str = None
    class_folders: list = field(default_factory=list)
    saved_images: list = field(default_factory=list)

    def add_indexes_folder(self):
        """
        Add a folder for the index
        """
        index_folder = f"{self.project.output_folder}/{self.index}"
        if not os.path.exists(index_folder):
            os.mkdir(index_folder)
        if os.path.exists(index_folder):
            self.index_folder = index_folder
        else:
            raise ValueError("index_folder failed to be created")

    def add_prompts_file(self):
        """
        Add a file for the prompt
        """
        if self.index_folder is None:
            raise ValueError("index_folder must be set")
        prompt_file = f"{self.index_folder}/{self.index}_prompt.txt"
        with open(prompt_file, "w") as f:
            f.write(self.prompt_line)
        if not os.path.exists(prompt_file):
            raise ValueError("prompt_file failed to be created")
        self.prompt_file = prompt_file

    def add_class_folders(self, classes: list[str]):
        """
        Add a folder for the class
        classes: a list of classes to add folders for
        """
        if self.index_folder is None:
            raise ValueError("index_folder must be set")
        for cls in classes:
            class_folder = f"{self.index_folder}/{cls.__name__}"
            if not os.path.exists(class_folder):
                os.mkdir(class_folder)
            if os.path.exists(class_folder):
                self.class_folders.append(class_folder)
            else:
                raise ValueError("class_folder failed to be created")

    def save_image(self, sd_model: str, img: PIL.Image):
        """
        Create a filename and path for the image
        """
        save_path = f"{self.index_folder}/{sd_model.title}/{self.index}.png"
        img.save(save_path)
        if not os.path.exists(save_path):
            raise ValueError("save_path failed to be created")
        self.saved_images.append(save_path)
        return save_path


if __name__ == "__main__":
    # open input/prison_full.txt
    with open("input/prison_full.txt", "r") as f:
        prompt = f.read()
    new_project = Project(id=str(uuid.uuid4()), prompt=prompt)
    image_indexes = []
    for index, line in enumerate(new_project.prompt.splitlines()):
        if line:
            print(f"index: {index}, line: {line}")
            image_index = ImageIndex(index=index, project=new_project, prompt_line=line)
            image_index.add_indexes_folder()
            image_index.add_prompts_file()
            image_index.add_class_folders(MODELS)
            image_indexes.append(image_index)
    for model in MODELS:
        sd_config = config_class(model)
        for image_index in image_indexes:
            make_image(
                sd_config,
                image_index,
            )
